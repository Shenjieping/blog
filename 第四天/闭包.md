```js
let x = 1;
function A(y) {
  let x = 2;
  function B(z) {
    console.log(x + y + z); // 7
  }
  return B;
}
let C = A(2);
C(3);
```

- GO 全局对象 window, 在堆内存中，存放的是浏览器内置的一些API
- VO(G) 全局变量对象，在全局上下文中创建的变量
- 基于var/function 在全局上下文中声明的变量也会给 GO 赋值一份（映射机制）
- ES6中的 let/const 等方式，在全局上下文中创建的全局变量和GO没有关系

## 函数执行
  
- 形成私有上下文
- 进栈执行
- 一系列操作（代码执行）
- 正常情况下，代码执行完，私有上下文会出栈，出栈好会释放，以此解决栈内存的空间
- 特殊情况下，如果私有上下文中的某个东西（一般是一个堆）被上下文以外的事物占用了，则上下文不会再出栈释放，也就是形成不销毁的上下文

## 浏览器的垃圾回收机制

- Chrome是基于 引用查找 来今夕垃圾回收的。
  + 开辟的堆内存，浏览器默认会在空闲的时候，查找所有内存的引用，把那些不被引用的内存释放
  + 开辟的栈内存，一般会在代码执行完就会释放，如果遇到上下文中的东西被外部引用，则不会被释放
  + 查找的引用方式如果形参相互引用，也会导致 内存泄漏，但是相对于IE会好很多
- IE 浏览器是基于 计数器 机制来进行内存管理
  + 创建的内存被引用一次，则计数 1，再被引用则计数2 ... 移出引用则减去1，当数字为0的时候，浏览器会把内存释放
  + 真实项目中某些情况下计数规则会出现问题，造成内存不会被会后，最后导致 内存泄漏

## 思考：那些情况会导致内存泄漏

JS高级程序设计 第三版 最后章节中有介绍

```js
let a = {name: 'shenjp'};
let b = a;
// 此时 {name: 'shenjp'} 的堆内存被 a,和b 同时占用，所以堆内存不会被释放
// 要想释放此堆内存需要：
a = null;
b = null;
// 将 a 和 b 都赋值给空指针，此时的堆内存就没有被任何占用，浏览器会在空闲的时候释放掉此内存
// 在项目中，将不使用的引用变量赋值为 null，一次节约内存
```

函数执行后会形成全局的私有上下文，这个上下文可能被释放，也可能不被释放，不论是否被释放，他的作用是：

- 保护：划分一个独立的代码执行区域，在这个区域中有自己的私有变量存储空间，而用到的私有变量和其他区域中的变量不会有任何的冲突（防止全局变量污染）
- 保存：如果上下文不被销毁，存储的私有变量的值，也不会被销毁，可以被下级上下文中调取使用

> 我们把函数执行，形成私有上下文，来保存和保护的机制，称之为 "闭包" => 他是一种机制而已
> 
> 市面上认为，只有形成的私有上下文不被释放，才算是闭包（因为，如果一旦释放，之前的东西也就不存在了）
> 
> 还有人认为，只有下一级上下文中用到了此上下文中的东西才算是闭包

## 作用域链机制

遇到一个变量，先看是不是自己私有的变量，如果不是则按作用域链向上查找，如果也不是，则继续向上查找，直到EC(G) 为止

- 当EC(C)执行完之后，会出栈释放
- EC(C)被释放之后，EC(A)也不会被释放，因为C的全局变量还一直用着A，所以不会被释放
- 如果想要释放EC(A),只需要把C 不再指向当前的地址就行，一般 C = null; 在浏览器空闲的时候会释放
