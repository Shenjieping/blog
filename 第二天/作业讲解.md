```js
let str = 100 + true + 21.2 + null + undefined + 'Tencent' + [] + null + 9 + false
// NaNTencentnull9false
// 加号，在两边出现字符串（或者对象）的情况下，+ 一定是字符串拼接
// 对象 本身是要转换为数字进行运算，只不过在转为数字的过程中要先转为字符串，而一旦转为字符串后，就会变成字符串拼接了。

// 对象转为字符串，先调用 valueOf 获取原始值（一般为基本类型的值），如果不是则继续调用 toString()
// 数组的 toSting() => '' [1, 2].toString() = '1,2'

// == 在进行比较时，如果两边的类型不一致，需要先转为一致的数据类型，然后进行比较
// === 绝对相等，两边的类型一致，值也一致相等，才会相等，不会进行类型转换


/* 
  1. 对象 == 字符串，对象转为字符串，[10] == '10' true
  null == undefined (三个等号下是不相等的)，但是和其他任何类型的值2. 都不相等 0 == null => false
  3. NaN和谁（包括自己）都不相等
  4. 剩下的情况下都是转换为数字再做比较
 */


[] == false;
![] == false;
/* 
  [] == false 都是转为数字进行比较
  [] 是先通过toString转为字符串'', 再通过 Number 转为 0
  flase 转为 0

  ![] == false
  运算符的优先级，会先计算 ![]
  ![] 是把 [] 转为布尔值，再进行取反（把其他类型转为布尔值的规律：只有 0/NaN/null/undefined/'' 这个五个值为false，其余的都是 true）
  [] => 转为布尔值为 true ,再取反为 false
  两边类型一致，就直接进行比较
 */


{} + 0 ? alert('ok') : alert('no');
0 + {} ? alert('ok') : alert('no');

// {} 很特殊，可以是对象、代码块（块级作用域
/* 
  {} + 0; 此处把 {} 当做是一个代码块，后面 + 0；最后就是0
  +value ，这个是做是数学运算

  {} 在运算符前面
    1. 在没有使用 ({}) 处理的情况下，不认为是数学运算
    2. {} 在运算符后面，认为是数学运算
 */
```

```js
var a = {}, b = '0', c = 0;
a[b] = 'shen';
a[c] = 'jp';
console.log(a[b]); //jp

var a = {}, b = Symbol('1'), c = Symbol('1');
a[b] = 'shen';
a[c] = 'jp';
console.log(a[b]); // shen

var a = {}, b = {n: '1'}, c = {m: '2'};
a[b] = 'shen';
a[c] = 'jp';
console.log(a[b]); // jp

/* 
  考察的是 对象中的属性名是什么格式的
  很多人认为属性名只能是 字符串，但是，普通对象的属性名，可以是基本的数据类型值,如果不是基本类型的值，要调用 toString 转为字符串
 */
```

```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);
console.log(b);

// JS中存在多种作用域（全局，函数私有的，块级私有的），代码之前之前，首先会形成自己的执行上下文，然后把上线文进栈，进栈后，在当前上下文中在依次执行代码

/* 
  所有的赋值操作：
    1. 创建值
    2. 创建变量
    3. 变量和指针关联
 */

/* 
  1. 先创建一个堆内存，里面存放 {n:1},同时提供一个地址 "0XFF00" 给栈内存中，将该内存地址赋值给 变量a
  2. 将a 赋值给b, 此时a和b 指向同一片内存 "0XFF00";
  3. 成员运算符(.) 的优先级比赋值运算符更高，所以，在 地址"0XFF00" 中添加了一个变量 x，此时值为 undefined
  3. 执行 a = {n: 2}; 再开辟一个新的内存空间，地址"0XFF11", 此时的 a 的指向发生变化，指向 地址 0XFF11
  4. 将内存"0XFF00" 中的x 指向 "0XFF11"地址

  最后就是
    a = {n:2}
  
 */
```

```js
var x = [12, 23];
function fn(y) { // [12, 23] 此时y和x指向同一片内存地址
  y[0] = 100; // [100, 23]
  y = [100]; // [100] // 此处将y 新开辟了一片地址，y和x失去关联
  y[1] = 200; // [100, 200]
  console.log(y);
}
fn(x);
console.log(x); // [100, 23] 

/* 
  函数堆
    把函数体的代码当做字符存储到堆中，"代码字符串" => 创建函数，如果不执行，就是一堆字符串，没有意义
    函数也是对象，也有自己的键值对，比如 name: fn, length: 1, prototype, __proto__
    创建函数的时候就定义函数的作用域 => 当前创建函数所在的上下文
 */
 /* 
  函数执行：
    形成一个全新的私有的上下文，供代码执行（进栈执行）
  */
  /* 
    执行代码之前
      初始化作用域链(scopeChain)
      初始化 this 指向
      初始化实参集合：arguments
      给形参赋值
      变量提升
      代码执行
   */
```

```js
let arr = [1, 2, 3, 4];
arr = arr.map(parseInt);
console.log(arr); // [1, NaN, NaN, NaN]

/* 
  parseInt(1, 0) // 1
  parseInt(2, 1) // NaN
  parseInt(3, 2) // NaN
  parseInt(4, 3) // NaN
 */
```

```js
console.log(a); // undefined
var a = 12;
a = 13;
console.log(a); // 13
```