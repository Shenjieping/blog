##   var let const 三者有什么区别？

  ### let VS const 突出的是指针指向已经等号复制的底层机制

    1. 等号赋值其实是指针指向的过程，先创建值，再创建变量（引申，堆内存上以及 AO/VO 上）最后指针关联
    2. let 创建的是变量，是因为可以修改当前变量的指针指向
    3. const 创建的变量，指针指向一旦确定，就不能再修改，（引申，平时也看到一些文章说，const 创建的是常量，我认为这种说法并不严谨，因为，毕竟他只是指针不能改变，如果指向的是一个对象，在不改变指针的情况下，我们是可以修改对象中的值的）
    4. 真实项目中，我们对于一些需要宏观管控的标识值，一般都是基于 const 创建（比如：在vue或者redux中，需要派发的行为标识）这样在用户误操作修改他的值后会报错
    5. 后续不能再更改指向的变量或者函数，也会基于const创建

  ### var VS let/const

    1. let 不存在变量提升（加一句，所以不能再声明变量之前使用）我之前在公司写项目，基本上都是基于ES6的let处理了，这样我会把后续需要用到的变量，在代码起始位置先声明加定义，给一个默认值，也就是 ”变量声明前置“。而且创建的函数也一般是基于函数表达式的方式创建，这样就保证只有在创建代码后函数才可以有效的执行
    2. let 不允许重复申明，（真实项目中，代码量比较多，除了申明前置外，还可以有效的避免重复声明报错的问题，而且我会尽可能的对业务进行拆分，每一个小模块在一个单独的闭包中，降低相同上下文中，变量声明的个数，这也是防止重复声明的办法）
    3. 在全局执行上下文中，基于let 声明的全局变量和全局对象和window没有关系，var 申明的变量会和 GO 有一个映射机制
    4. 暂时性死区问题，基于typeof 检测一个未声明的变量时，不会报错，结果是 undefined (引申，我之前看过一些源码，比如JQ，他们利用这个机制，检测上下文中是否存在window/module，从而验证是浏览器环境还是node环境)，但是如果此变量在后面会被let声明，则直接报错，错误信息是，不允许在声明之前使用变量（这个是在浏览器词法解释阶段处理的事情）
    5. 我认为除了上述说到的，最重要的是，let/const 都会把当前所以在的大括号，（除函数以外）自以为一个全新的块级上下文，应用这个机制，我们在项目开发的时候，如果遇到循环事件绑定的时候，无需在用闭包存储起来了，只需要基于let 的块级作用域特征即可解决，很方便，当然还有一些其他的应用，也是利用的块级上下文解决的


```js
typeof n // => undefined 检测一个未声明的变量，不会报错，结果是undefined

// 如果下面用let 定义了
let n = 10; // 报错，不能在定义之前报错
```